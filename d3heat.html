
<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>
<style>

html, body {
  position: relative;
  height: 100%;
}

#plot1 {
    width: 100%;
    height: 100%;;
}

svg,
canvas {
  position: absolute;
  image-rendering: optimizeSpeed;
  image-rendering: crisp-edges;
  image-rendering: -moz-crisp-edges;
  image-rendering: -webkit-optimize-contrast;
  image-rendering: optimize-contrast;
  -ms-interpolation-mode: nearest-neighbor;
}

.axis text {
  font: 10px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.axis path {
  /* display: none; */
}

.grid .tick {
    stroke: lightgrey;
    opacity: 0.7;
}
.grid path {
      stroke-width: 0;
}

</style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
</head>
<body>
<!--<script src="d3.v3.min.js"></script>-->
<script>
debug = false;
var fixAspect = function(target_ratio, xmin, xmax, ymin, ymax, width, height) {
    var yrange = (ymax - ymin);
    var ycenter = (ymax + ymin) / 2.0;
    var xrange = (xmax - xmin);
    var xcenter = (xmax + xmin) / 2.0;
    var graph_ratio = width / height;
    var ratio = yrange/xrange * graph_ratio;
    //console.log('ratios:', ratio, target_ratio);
    if (isNaN(ratio) || ratio == target_ratio) { return };
    if (ratio < target_ratio) { // y-range is too small
        yrange = target_ratio * xrange / graph_ratio;
    }
    if (ratio > target_ratio) {
        xrange = yrange / target_ratio * graph_ratio;
    }
            
    //console.log('ranges:', yrange, xrange);
    output = {
        'xmin': xcenter - xrange/2.0, 
        'xmax': xcenter + xrange/2.0,
        'ymin': ycenter - yrange/2.0, 
        'ymax': ycenter + yrange/2.0
    }
    return output;
}
jet_array = [
    [0, 0, 127, 255], [0, 0, 132, 255], [0, 0, 136, 255], [0, 0, 141, 255], 
    [0, 0, 145, 255], [0, 0, 150, 255], [0, 0, 154, 255], [0, 0, 159, 255], 
    [0, 0, 163, 255], [0, 0, 168, 255], [0, 0, 172, 255], [0, 0, 177, 255], 
    [0, 0, 181, 255], [0, 0, 186, 255], [0, 0, 190, 255], [0, 0, 195, 255], 
    [0, 0, 199, 255], [0, 0, 204, 255], [0, 0, 208, 255], [0, 0, 213, 255], 
    [0, 0, 218, 255], [0, 0, 222, 255], [0, 0, 227, 255], [0, 0, 231, 255], 
    [0, 0, 236, 255], [0, 0, 240, 255], [0, 0, 245, 255], [0, 0, 249, 255], 
    [0, 0, 254, 255], [0, 0, 255, 255], [0, 0, 255, 255], [0, 0, 255, 255], 
    [0, 0, 255, 255], [0, 3, 255, 255], [0, 7, 255, 255], [0, 11, 255, 255], 
    [0, 15, 255, 255], [0, 19, 255, 255], [0, 23, 255, 255], [0, 27, 255, 255], 
    [0, 31, 255, 255], [0, 35, 255, 255], [0, 39, 255, 255], [0, 43, 255, 255], 
    [0, 47, 255, 255], [0, 51, 255, 255], [0, 55, 255, 255], [0, 59, 255, 255],
    [0, 63, 255, 255], [0, 67, 255, 255], [0, 71, 255, 255], [0, 75, 255, 255], 
    [0, 79, 255, 255], [0, 83, 255, 255], [0, 87, 255, 255], [0, 91, 255, 255], 
    [0, 95, 255, 255], [0, 99, 255, 255], [0, 103, 255, 255], [0, 107, 255, 255], 
    [0, 111, 255, 255], [0, 115, 255, 255], [0, 119, 255, 255], [0, 123, 255, 255], 
    [0, 127, 255, 255], [0, 131, 255, 255], [0, 135, 255, 255], [0, 139, 255, 255], 
    [0, 143, 255, 255], [0, 147, 255, 255], [0, 151, 255, 255], [0, 155, 255, 255], 
    [0, 159, 255, 255], [0, 163, 255, 255], [0, 167, 255, 255], [0, 171, 255, 255], 
    [0, 175, 255, 255], [0, 179, 255, 255], [0, 183, 255, 255], [0, 187, 255, 255], 
    [0, 191, 255, 255], [0, 195, 255, 255], [0, 199, 255, 255], [0, 203, 255, 255], 
    [0, 207, 255, 255], [0, 211, 255, 255], [0, 215, 255, 255], [0, 219, 255, 255], 
    [0, 223, 251, 255], [0, 227, 248, 255], [1, 231, 245, 255], [4, 235, 242, 255], 
    [7, 239, 239, 255], [10, 243, 235, 255], [14, 247, 232, 255], [17, 251, 229, 255], 
    [20, 255, 226, 255], [23, 255, 222, 255], [26, 255, 219, 255], [30, 255, 216, 255], 
    [33, 255, 213, 255], [36, 255, 210, 255], [39, 255, 206, 255], [43, 255, 203, 255], 
    [46, 255, 200, 255], [49, 255, 197, 255], [52, 255, 194, 255], [55, 255, 190, 255], 
    [59, 255, 187, 255], [62, 255, 184, 255], [65, 255, 181, 255], [68, 255, 178, 255], 
    [71, 255, 174, 255], [75, 255, 171, 255], [78, 255, 168, 255], [81, 255, 165, 255], 
    [84, 255, 161, 255], [88, 255, 158, 255], [91, 255, 155, 255], [94, 255, 152, 255], 
    [97, 255, 149, 255], [100, 255, 145, 255], [104, 255, 142, 255], [107, 255, 139, 255], 
    [110, 255, 136, 255], [113, 255, 133, 255], [116, 255, 129, 255], [120, 255, 126, 255], 
    [123, 255, 123, 255], [126, 255, 120, 255], [129, 255, 116, 255], [133, 255, 113, 255], 
    [136, 255, 110, 255], [139, 255, 107, 255], [142, 255, 104, 255], [145, 255, 100, 255], 
    [149, 255, 97, 255], [152, 255, 94, 255], [155, 255, 91, 255], [158, 255, 88, 255], 
    [161, 255, 84, 255], [165, 255, 81, 255], [168, 255, 78, 255], [171, 255, 75, 255], 
    [174, 255, 71, 255], [178, 255, 68, 255], [181, 255, 65, 255], [184, 255, 62, 255], 
    [187, 255, 59, 255], [190, 255, 55, 255], [194, 255, 52, 255], [197, 255, 49, 255], 
    [200, 255, 46, 255], [203, 255, 43, 255], [206, 255, 39, 255], [210, 255, 36, 255], 
    [213, 255, 33, 255], [216, 255, 30, 255], [219, 255, 26, 255], [222, 255, 23, 255], 
    [226, 255, 20, 255], [229, 255, 17, 255], [232, 255, 14, 255], [235, 255, 10, 255], 
    [239, 254, 7, 255], [242, 250, 4, 255], [245, 247, 1, 255], [248, 243, 0, 255], 
    [251, 239, 0, 255], [255, 235, 0, 255], [255, 232, 0, 255], [255, 228, 0, 255], 
    [255, 224, 0, 255], [255, 221, 0, 255], [255, 217, 0, 255], [255, 213, 0, 255], 
    [255, 210, 0, 255], [255, 206, 0, 255], [255, 202, 0, 255], [255, 199, 0, 255], 
    [255, 195, 0, 255], [255, 191, 0, 255], [255, 188, 0, 255], [255, 184, 0, 255], 
    [255, 180, 0, 255], [255, 176, 0, 255], [255, 173, 0, 255], [255, 169, 0, 255], 
    [255, 165, 0, 255], [255, 162, 0, 255], [255, 158, 0, 255], [255, 154, 0, 255], 
    [255, 151, 0, 255], [255, 147, 0, 255], [255, 143, 0, 255], [255, 140, 0, 255], 
    [255, 136, 0, 255], [255, 132, 0, 255], [255, 128, 0, 255], [255, 125, 0, 255], 
    [255, 121, 0, 255], [255, 117, 0, 255], [255, 114, 0, 255], [255, 110, 0, 255], 
    [255, 106, 0, 255], [255, 103, 0, 255], [255, 99, 0, 255], [255, 95, 0, 255], 
    [255, 92, 0, 255], [255, 88, 0, 255], [255, 84, 0, 255], [255, 81, 0, 255], 
    [255, 77, 0, 255], [255, 73, 0, 255], [255, 69, 0, 255], [255, 66, 0, 255], 
    [255, 62, 0, 255], [255, 58, 0, 255], [255, 55, 0, 255], [255, 51, 0, 255], 
    [255, 47, 0, 255], [255, 44, 0, 255], [255, 40, 0, 255], [255, 36, 0, 255], 
    [255, 33, 0, 255], [255, 29, 0, 255], [255, 25, 0, 255], [255, 21, 0, 255], 
    [254, 18, 0, 255], [249, 14, 0, 255], [245, 10, 0, 255], [240, 7, 0, 255], 
    [236, 3, 0, 255], [231, 0, 0, 255], [227, 0, 0, 255], [222, 0, 0, 255], 
    [218, 0, 0, 255], [213, 0, 0, 255], [208, 0, 0, 255], [204, 0, 0, 255], 
    [199, 0, 0, 255], [195, 0, 0, 255], [190, 0, 0, 255], [186, 0, 0, 255], 
    [181, 0, 0, 255], [177, 0, 0, 255], [172, 0, 0, 255], [168, 0, 0, 255], 
    [163, 0, 0, 255], [159, 0, 0, 255], [154, 0, 0, 255], [150, 0, 0, 255], 
    [145, 0, 0, 255], [141, 0, 0, 255], [136, 0, 0, 255], [132, 0, 0, 255]
  ];

var _colormap_array = jet_array;
_colormap_array.push([0,0,0,0]); // overflow color

var dispatch = d3.dispatch("update_main", "update_colorbar");

var draw_colorbar = function(target_id, transform, shared_dims, colormap) {
    var outer = d3.select("#" + target_id);
    var target = outer.append("div");
    var offset_right = 0;
    target.attr("width", 105)
    .attr("height", outer.node().clientHeight)
    .style("display", "inline-block")
    .style("width", 105 + "px")
    .style("height", outer.node().clientHeight + "px");
    var container = target.node();
    var numberOfTicks = 4;
    var backing_canvas = document.createElement('canvas');
    var _redraw_backing = true;
    var margin_left = container.clientWidth - 105;
    var margin = {top: 10, right: 50, bottom: 50, left: margin_left},
        width = container.clientWidth - margin.left - margin.right,
        height = container.clientHeight - margin.top - margin.bottom;
    console.log("colorbar width:", width);
        
    var x = d3.scale.linear()
        .domain([0, 10])
        .range([0, width]);

    var y = ((transform == 'log') ? d3.scale.log() : d3.scale.linear())
        .domain([shared_dims.zmin, shared_dims.zmax])
        .range([height, 0]);
    
    var yAxis = d3.svg.axis()
      .scale(y)
        //.tickSize(-width)
        .ticks(numberOfTicks)
	    .tickPadding(10)	
	    .tickSubdivide(true)	
      .orient("right");
    
    target.append("canvas")
      .attr("width", width)
      .attr("height", height)
      .attr("class", "colorbar")
      .style("width", width + "px")
      .style("height", height + "px")
      .style("padding-left", margin.left + "px")
      .style("padding-right", margin.right + "px")
      .call(drawImage);
      
  var zoom = d3.behavior.zoom().x(x).y(y).on("zoom.colorbar", zoomed);
  var resetzoom = function() {
    zoom.translate([0,0]).scale(1);
    zoomed()
  }
  
  var svg = target.append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .call(zoom)
      .on("dblclick.zoom", null)
      .on("dblclick.resetzoom", resetzoom);
         
    svg.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate(" + margin.left + width + ",0)")
      .call(yAxis);
      
    function drawImage(canvas) {
        var maxColorIndex = 255,
            overflowIndex = 256,
            context = canvas.node().getContext("2d"),
            ctx = backing_canvas.getContext("2d");
            
        if (_redraw_backing) {
            _redraw_backing = false;        
            backing_canvas.width = 1;
            backing_canvas.height = 256;
            var image = ctx.createImageData(1, 256);
            var data = image.data;
            for (var yp = 255, p = -1; yp >= 0; --yp) {
                var c = colormap[yp];
                data[++p] = c[0];
                data[++p] = c[1];
                data[++p] = c[2];
                data[++p] = c[3];
            }
            ctx.putImageData(image, 0, 0);
        }
	       
        context.clearRect(0,0, context.canvas.width, context.canvas.height);
        if (context.mozImageSmoothingEnabled) context.mozImageSmoothingEnabled = false;
        if (context.imageSmoothingEnabled) context.imageSmoothingEnabled = false;
        context.drawImage(ctx.canvas, 0, 0, 1, 256, 0, 0, context.canvas.width, context.canvas.height);
    }
  
    function zoomed() {
	    svg.select(".y.axis").call(yAxis);
	    shared_dims.zmax = Math.max.apply(Math, y.domain());
	    shared_dims.zmin = Math.min.apply(Math, y.domain());
	    dispatch.update_main();
	    //target.select('canvas.mainplot').call(drawImage, plotdata);
    }
}

d3.json("sample_data/512.json", function(error, heatmap) {
  var show_grid = true;
  var show_colorbar = true;
  var target_id = "plot1"
  var outer = d3.select("#" + target_id);
  var target = outer.append("div");
  var offset_right = (show_colorbar) ? 120 : 0;
  target.attr("width", outer.node().clientWidth - offset_right)
    .attr("height", outer.node().clientHeight)
    .style("display", "inline-block")
    .style("width", outer.node().clientWidth - offset_right + "px")
    .style("height", outer.node().clientHeight + "px");
  var container = target.node();
  var backing_canvas = document.createElement('canvas');
  var _redraw_backing = true;
  var numberOfTicks = 4;
  var target_ratio = 1.0;
 
  var get_sxdx; 
  var transforms = {
    "lin": function(x) {return x},
    "log": function(x) {
        if (x > 0) { return Math.log(x)/Math.LN10 }
        else { return NaN }
    }
  }
  var inverse_transforms = {
    "lin": function(x) {return x},
    "log": function(x) {return Math.pow(10, x)}
  }
  
  var transform = 'log',
    t = transforms[transform],
    tinv = inverse_transforms[transform];
  
  var margin = {top: 10, right: 10, bottom: 50, left: 50},
        width = container.clientWidth - margin.left - margin.right,
        height = container.clientHeight - margin.top - margin.bottom;
  
  /*
  var dims = {
    xmin: 0,
    xmax: 128,
    ymin: 0, 
    ymax: 128,
    xdim: 128,
    ydim: 128,
    zmin: 1.0,
    zmax: 2500.0
  }
  */
  var dims = {
    xmin: 0,
    xmax: 128,
    ymin: 0, 
    ymax: 128,
    xdim: 512,
    ydim: 512,
    zmin: 1.0,
    zmax: 2500.0
  }
  // create working copy of zmax and zmin, for zooming colorbar
  var zdims = {
    zmin: dims.zmin,
    zmax: dims.zmax
  }
  
  zdims.zmin = get_minimum(heatmap, transforms['lin'], Infinity);
  zdims.zmax = get_maximum(heatmap, transforms['lin'], -Infinity);
  
  get_sxdx = function(){
        if (!dims.dx){ dims.dx = (dims.xmax - dims.xmin)/(dims.xdim); }
        if (!dims.dy){ dims.dy = (dims.ymax - dims.ymin)/(dims.ydim); }
        
        graph_xmax = Math.max.apply(Math, x.domain());
        graph_xmin = Math.min.apply(Math, x.domain());
        graph_ymax = Math.max.apply(Math, y.domain());
        graph_ymin = Math.min.apply(Math, y.domain());
        
        var xmin = Math.max(graph_xmin, dims.xmin), xmax = Math.min(graph_xmax, dims.xmax);
        var ymin = Math.max(graph_ymin, dims.ymin), ymax = Math.min(graph_ymax, dims.ymax);
        if (debug) {
            console.log('x', xmin,xmax, 'y', ymin,ymax, 'w', (xmax-xmin), 'h', (ymax-ymin));
            console.log('dims', dims);
        }
        
        var sx  = (xmin - dims.xmin)/dims.dx, sy  = (dims.ymax - ymax)/dims.dy,
            sx2 = (xmax - dims.xmin)/dims.dx, sy2 = (dims.ymax - ymin)/dims.dy,
            sw = sx2 - sx, sh = sy2 - sy;
        if (debug)
            console.log('sx', sx, 'sy', sy, 'sw', sw, 'sh', sh, '   sx2 ', sx2, 'sy2 ', sy2);
        
        var dx = x(xmin),
            dy = y(ymax),
            dw = x(xmax) - dx, 
            dh = y(ymin) - dy;
        if (debug)
            console.log('dx', dx, 'dy', dy, 'dw', dw, 'dh', dh);
        return {sx:sx, sy:sy, sw:sw, sh:sh, dx:dx, dy:dy, dw:dw, dh:dh}
    };
    
  
  plotdata = make_plotdata(heatmap, dims, zdims, t, tinv);

  var dx = heatmap[0].length,
      dy = heatmap.length;
      

  // Fix the aspect ratio.
  var limits = fixAspect(target_ratio, dims.xmin, dims.xmax, dims.ymin, dims.ymax, width, height);
  console.log(limits);
  //var ka = dy / dx, kb = height / width;
  //if (ka < kb) height = width * ka;
  //else width = height / ka;

  var x = d3.scale.linear()
      .domain([limits.xmin, limits.xmax])
      .range([0, width]);

  var y = d3.scale.linear()
      .domain([limits.ymin, limits.ymax])
      .range([height, 0]);

  var color = d3.scale.linear()
      .domain([750, 1150, 1350, 1550, 1750, 1950, 2150, 2950])
      //.range(["#0a0", "#6c0", "#ee0", "#eb4", "#eb9", "#fff"]);
      /*#00007F: dark blue
        #0000FF: blue
        #007FFF: azure
        #00FFFF: cyan
        #7FFF7F: light green
        #FFFF00: yellow
        #FF7F00: orange
        #FF0000: red
        #7F0000: dark red*/
      .range(["#00007F", "#0000FF","#007FFF", "#00FFFF","#7FFF7F","#FFFF00","#FF7F00","#FF0000","#7F0000"]);

  var xAxis = d3.svg.axis()
      .scale(x)
        //.tickSize(-height)
	    .ticks(numberOfTicks)
	    .tickPadding(10)	
	    .tickSubdivide(true)	
      .orient("bottom");

  var yAxis = d3.svg.axis()
      .scale(y)
        //.tickSize(-width)
        .ticks(numberOfTicks)
	    .tickPadding(10)	
	    .tickSubdivide(true)	
      .orient("left");
  
  target.append("canvas")
      .attr("width", width)
      .attr("height", height)
      .attr("class", "mainplot")
      .style("width", width + "px")
      .style("height", height + "px")
      .style("padding-left", margin.left + "px")
      .style("padding-right", margin.right + "px")
      .call(drawImage, plotdata);      
      
  var zoom = d3.behavior.zoom().x(x).y(y).on("zoom.main", zoomed);
  var resetzoom = function() {
    //zdims.zmax = dims.zmax;
    //zdims.zmin = dims.zmin;
    //x.domain([xaxis_min, xaxis_max]);
    //y.domain([yaxis_min, yaxis_max]);
    zoom.translate([0,0]).scale(1);
    zoomed();
    dispatch.update_main();
  }
  
  var svg = target.append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .call(zoom)
      .on("dblclick.zoom", null)
      .on("dblclick.resetzoom", resetzoom);
      //.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
      //.attr("width", width)
      //.attr("height", height);
      
  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(" + margin.left + "," + height + ")")
      .call(xAxis);
      //.call(removeZero);

  svg.append("g")
      .attr("class", "y axis")
      .attr("transform", "translate(" + margin.left + ",0)")
      .call(yAxis);
      //.call(removeZero);
      
  if (show_grid) {
    //var yAxisGrid = yAxis.ticks(numberOfTicks)
    //    .tickSize(width, 0)
    //    .tickFormat("")
    //    .orient("right");

    //var xAxisGrid = xAxis.ticks(numberOfTicks)
    //    .tickSize(height, 0)
    //    .tickFormat("")
    //    .orient("top");

    var xAxisGrid = d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .ticks(numberOfTicks)
        .tickPadding(10)
    
    var yAxisGrid = d3.svg.axis()
      .scale(y)
        //.tickSize(-width)
        .ticks(numberOfTicks)
	    .tickPadding(10)	
	    .tickSubdivide(true)	
        .orient("left");
        
    svg.append("g")         
        .attr("class", "grid x")
        .attr("transform", "translate(" + margin.left + "," + height + ")")
        .call(xAxisGrid
            .tickSize(-height, 0, 0)
            .tickFormat("")
        )

    svg.append("g")         
        .attr("class", "grid y")
        .attr("transform", "translate(" + margin.left + ",0)")
        .call(yAxisGrid
            .tickSize(-width, 0, 0)
            .tickFormat("")
        )
  }

      
  svg.append("defs").append("clipPath")
    .attr("id", target_id + "_clip") // local def
    .append("rect")
    .attr("width", width)
    .attr("height", height);

  // Compute the pixel colors; scaled by CSS.
  function drawImage(canvas, plotdata) {
    var maxColorIndex = 255,
        overflowIndex = 256,
        context = canvas.node().getContext("2d"),
        ctx = backing_canvas.getContext("2d");
        
    if (_redraw_backing) {
        _redraw_backing = false;        
        backing_canvas.width = dims.xdim;
        backing_canvas.height = dims.ydim;
        var image = ctx.createImageData(dx, dy);
        var data = image.data;
        for (var yp = 0, p = -1; yp < dims.ydim; ++yp) {
          for (var xp = 0; xp < dims.xdim; ++xp) {
            var c = _colormap_array[plotdata[yp][xp]];
            //var c = d3.rgb(color(heatmap[yp][xp]));
            data[++p] = c[0];
            data[++p] = c[1];
            data[++p] = c[2];
            data[++p] = c[3];
            //image.data[++p] = c.r;
            //image.data[++p] = c.g;
            //image.data[++p] = c.b;
            //image.data[++p] = 255;
          }
        }
        ctx.putImageData(image, 0, 0);
    }
    
	//context.mozImageSmoothingEnabled = false;
	//context.webkitImageSmoothingEnabled = false;
	//context.msImageSmoothingEnabled = false;
	//context.imageSmoothingEnabled = false;
	var x0=x(dims.xmin),
	    y0=y(dims.ymin),
	    x1=x(dims.xmax),
	    y1=y(dims.ymax);
	   
    context.clearRect(0,0, context.canvas.width, context.canvas.height);
    if (context.mozImageSmoothingEnabled) context.mozImageSmoothingEnabled = false;
    if (context.imageSmoothingEnabled) context.imageSmoothingEnabled = false;
    var sxdx = get_sxdx();
    context.drawImage(ctx.canvas, sxdx.sx, sxdx.sy, sxdx.sw, sxdx.sh, sxdx.dx, sxdx.dy, sxdx.dw, sxdx.dh);
  }

  function removeZero(axis) {
    axis.selectAll("g").filter(function(d) { return !d; }).remove();
  }
  
    // call after setting transform
    function make_plotdata(source_data, dims, clim, t, tinv) {
        // source_data is 2d array
        // dims is object with dim, max and min for x,y,z
        // t is transform (is function(x) {return x} for linear)
        // tinv is inverse transform (is function(x) {return x} for linear)
        var maxColorIndex = 255;
        var overflowIndex = 256;
        var width = dims.xdim;
        var height = dims.ydim;
        var tzmax = t(clim.zmax);
        var tzmin = t(clim.zmin);
        //var tzmax = get_maximum(this.source_data, this.t);
        //var tzmin = get_minimum(this.source_data, this.t);
        //if (isNaN(tzmin)) tzmin = 0;
        
        if (!(isFinite(tzmin))) {
            tzmin = get_minimum(source_data, t);
            clim.zmin = tinv(tzmin);
        }
        var data = source_data; 
        var plotdata = [], rowdata;
        
        // plotdata is stored in row-major order ("C"), where row is "y"
        var z, r, c, plotz;
        for (r = 0; r < height; r++) {
            plotdata[r] = [];
            for (c = 0; c < width; c++) {
                z = data[r][c];
                plotz = Math.floor(((t(z) - tzmin) / (tzmax - tzmin)) * maxColorIndex);
                
                if (isNaN(plotz) || (z == null)) { plotz = overflowIndex }
                else if (plotz > maxColorIndex) { plotz = maxColorIndex }
                else if (plotz < 0) { plotz = 0 }
                plotdata[r][c]=plotz;
            }
            //plotdata[r] = rowdata.slice();
        }
        // global flag:
        _redraw_backing = true;
        return plotdata
    };
    
    function get_minimum(array, transform, existing_min) {
        var new_min;
        for (var i in array) {
            var subarr = array[i];
            if (subarr == null) { return existing_min }
            if (subarr.length == undefined) {
                var t_el = transform(subarr);
                if (isFinite(t_el)) new_min = t_el;
            } else {
                new_min = get_minimum(subarr, transform, existing_min);
            }
            if (existing_min == undefined || new_min < existing_min) {
                var existing_min = new_min;
            }
        }
        return existing_min
    };
    
    function get_maximum(array, transform, existing_max) {
        var new_max;
        for (var i in array) {
            var subarr = array[i];
            if (subarr == null) { return existing_max }
            if (subarr.length == undefined) {
                var t_el = transform(subarr);
                if (isFinite(t_el)) new_max = t_el;
            } else {
                new_max = get_maximum(subarr, transform, existing_max);
            }
            if (existing_max == undefined || new_max > existing_max) {
                var existing_max = new_max;
            }
        }
        return existing_max
    };
  
 
    function zoomed() {
        svg.select(".x.axis").call(xAxis);
        svg.select(".y.axis").call(yAxis);
        if (show_grid) {
            svg.select(".grid.x").call(xAxisGrid);
            svg.select(".grid.y").call(yAxisGrid);
        }
        //if (line) svg.selectAll('path.line').attr('d', line);  

        //if (points) points.selectAll('circle').attr("transform", function(d) { 
        //    return "translate(" + x(d.point.x) + "," + y(d.point.y) + ")"; }
        //);
        target.select('canvas.mainplot').call(drawImage, plotdata);
    }
    
    dispatch.on("update_main", function() {
        plotdata = make_plotdata(heatmap, dims, zdims, t, tinv);
        _redraw_backing = true;
        zoomed();
    });
    draw_colorbar(target_id, transform, zdims, jet_array);
});

</script>
<div id="plot1">
</div>
</body>
</html>


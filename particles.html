<!doctype html>
<html lang="en-us">
<head>
  <meta charset="UTF-8">
  <title>Easing Test</title>
  <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
  <script src="linePolygonIntersect.js"></script>
  <style type="text/css">
    svg {
      margin: 0px;
    }
    svg circle.neutron {
      fill: blue;
    }
    svg polygon.detector {
      fill: LightGrey;
    }
    svg polygon.sample {
      fill: green;
    }
    
  </style>
</head>
<body>
  <script>
    var width = 960,
      height = 500,
			xOffset = 0,
			yOffset = 130,
      apertureHeight = 40,
			r = 2,
      rate = 0.5, // per second
      speed = 0.25,
      wavelength = 5.0,
      k_0 = 2*Math.PI/wavelength,
      max_angle = 2.0 * Math.PI/180.0; // 5 degree

    var sample_def = [{
      "name": "sample",
      "cx": 480,
      "cy": yOffset,
      "r": 7.5,
      "angle": Math.PI*(0.5 - 1/30),
      "thickness": 15,
      "width": 125,
      "sld": 1e-2
    }]
    
    var detector_def = [{
      "name": "detector",
      "cx": sample_def[0].cx, // center of rotation
      "cy": sample_def[0].cy,
      "r": 450,
      "angle": Math.PI/8.0,
      "thickness": 30,
      "width": 75
    }];
    
    var slits_def = [
      {
        "name": "slit1",
        "aperture": 10,
        "cx": sample_def[0].cx, // center of rotation
        "cy": sample_def[0].cy,
        "r": 400, // distance from center of rot.
        "angle": Math.PI,
        "thickness": 5,
        "blade_width": 75
      },
      {
        "name": "slit2",
        "aperture": 10,
        "cx": sample_def[0].cx, // center of rotation
        "cy": sample_def[0].cy,
        "r": 125, // distance from center of rot.
        "angle": Math.PI,
        "thickness": 5,
        "blade_width": 75
      },
      {
        "name": "slit3",
        "aperture": 10,
        "cx": sample_def[0].cx, // center of rotation
        "cy": sample_def[0].cy,
        "r": 125, // distance from center of rot.
        "angle": detector_def[0].angle,
        "thickness": 5,
        "blade_width": 75
      },
      {
        "name": "slit4",
        "aperture": 10,
        "cx": sample_def[0].cx, // center of rotation
        "cy": sample_def[0].cy,
        "r": 400, // distance from center of rot.
        "angle": detector_def[0].angle,
        "thickness": 5,
        "blade_width": 75
      }
    ];
    
    var svg = d3.select("body").append("svg")
      .attr({
        width: width,
        height: height
      });
    
    var slit = svg.selectAll("g.slit")
      .data(slits_def)
      .enter().append("g")
        .classed("slit", true)
    
    function render_slit_blade(above) {
      var renderer = function(d) {
        var sign = (above) ? 1 : -1;
        var s = Math.sin(d.angle), 
            c = Math.cos(d.angle),
            x = d.cx + c * d.r,
            y = d.cy + s * d.r,
            dax =  sign*s*d.aperture/2.0,
            day = -sign*c*d.aperture/2.0,
            dbx =  sign*s*d.blade_width,
            dby = -sign*c*d.blade_width;
            points = "";
        points += (x + dax + (c*d.thickness/2.0)).toFixed() + ",";
        points += (y + day + (s*d.thickness/2.0)).toFixed() + " ";
        
        points += (x + dax - (c*d.thickness/2.0)).toFixed() + ",";
        points += (y + day - (s*d.thickness/2.0)).toFixed() + " ";
        
        points += (x + dax + dbx - (c*d.thickness/2.0)).toFixed() + ",";
        points += (y + day + dby - (s*d.thickness/2.0)).toFixed() + " ";
        
        points += (x + dax + dbx + (c*d.thickness/2.0)).toFixed() + ",";
        points += (y + day + dby + (s*d.thickness/2.0)).toFixed() + " ";
        return points
      }
      return renderer;
    }
    var render_slit_above = render_slit_blade(true);
    var render_slit_below = render_slit_blade(false);
    
    slit.append("polygon")
      .classed("above", true)
      .attr("points", render_slit_above)
      
    slit.append("polygon")
      .classed("below", true)
      .attr("points", render_slit_below)
    
    function render_detector(d){
      var s = Math.sin(d.angle), 
          c = Math.cos(d.angle),
          x = d.cx + c * d.r,
          y = d.cy + s * d.r,
          dbx = -s*d.width,
          dby =  c*d.width;
          points = "";
      points += (x - dbx/2 + (c*d.thickness/2.0)).toFixed() + ",";
      points += (y - dby/2 + (s*d.thickness/2.0)).toFixed() + " ";
      
      points += (x - dbx/2 - (c*d.thickness/2.0)).toFixed() + ",";
      points += (y - dby/2 - (s*d.thickness/2.0)).toFixed() + " ";
      
      points += (x + dbx/2 - (c*d.thickness/2.0)).toFixed() + ",";
      points += (y + dby/2 - (s*d.thickness/2.0)).toFixed() + " ";
      
      points += (x + dbx/2 + (c*d.thickness/2.0)).toFixed() + ",";
      points += (y + dby/2 + (s*d.thickness/2.0)).toFixed() + " ";
      return points
    }
    var detector = svg.selectAll(".detector")
      .data(detector_def)
      .enter().append("polygon")
        .classed("detector", true)
        .attr("points", render_detector)
     
    var drag_detector = d3.behavior.drag()
      .on("drag", dragmove_detector)
      .origin(function(d) { 
        var s = Math.sin(d.angle), 
            c = Math.cos(d.angle),
            x = d.cx + c * d.r,
            y = d.cy + s * d.r;
        return {x: x, y: y}
      })  
      
    function dragmove_detector(d) {
      //if (!d3.select(this).classed("draggable")) {return}
      var new_angle = Math.atan2(d3.event.y - d.cy, d3.event.x - d.cx)
      d.angle = new_angle;
      slits_def[2].angle = slits_def[3].angle = new_angle;
      d3.select(this).attr("points", render_detector);
      svg.selectAll("g.slit polygon.above")
        .attr("points", render_slit_above)
      svg.selectAll("g.slit polygon.below")
        .attr("points", render_slit_below)
    }
    
    detector.call(drag_detector);
    
    var sample = svg.selectAll(".sample")
      .data(sample_def)
      .enter().append("polygon")
        .classed("sample", true)
        .attr("points", render_detector)
    var drag_sample = d3.behavior.drag()
      .on("drag", dragmove_sample)
      .on("dragend", function(d) {d.ref_angle = null}) 
      .origin(function(d) { 
        var s = Math.sin(d.angle), 
            c = Math.cos(d.angle),
            x = d.cx + c * d.r,
            y = d.cy + s * d.r;
        return {x: x, y: y}
      })  
      
    function dragmove_sample(d) {
      //if (!d3.select(this).classed("draggable")) {return}
      var new_angle = Math.atan2(d3.event.y - d.cy, d3.event.x - d.cx);
      if (d.ref_angle == null) { 
        d.ref_angle = new_angle - d.angle; 
        console.log("setting reference angle: ", new_angle*180/Math.PI, d.angle*180/Math.PI);
        return 
      }
      console.log(new_angle*180/Math.PI, d.angle*180/Math.PI, d.ref_angle*180/Math.PI);
      d.angle = new_angle - d.ref_angle;
      d3.select(this).attr("points", render_detector);
    }
    
    sample.call(drag_sample);
    
    function reflection_probability(angle, outer, sld, k_0) {
      var k_0z = Math.sin(angle) * k_0,
          k_0z_sq = k_0z * k_0z,
          potential = 4*Math.PI*sld;
      if (outer) {
        if (k_0z_sq < potential) {
          return 1.0;
        }
        else {
          var n1 = Math.sqrt(1.0 - potential/k_0z_sq),
              n0 = 1;
          var r = (n1 - n0) / (n1 + n0);
          return r*r;
        }
      } else {
        var n1 = Math.sqrt(1.0 + potential/k_0z_sq),
            n0 = 1;
        var r = (n1 - n0) / (n1 + n0);
        return r*r;
      }
    }
        
  var gauss = d3.random.normal(0,1);
  var t = d3.timer(tick);
  var ticker; // = setInterval(tick, 20);
  var particles = [];
  var part_id = 0,
      prev_elapsed = 0,
      detected = [];
  function detection_handler(elapsed) {
    detected.push(elapsed);
  }    
  function tick(elapsed) {
    //var elapsed = elapsed || (new Date()).getTime();
    var dt = 1000.0/60.0;
    var number = Math.ceil(1000.0/dt * rate);
    for (var i=0; i<number; i++) {
      var particle = {
        y_start: (Math.random() - 0.5)*apertureHeight + yOffset,
        x_start: (gauss() - 1.0) * speed * 20 * dt,
        angle: (Math.random() - 0.5) * max_angle,
        speed: speed,
        t0: elapsed,
        id: part_id++
      }
      particle.vx = Math.cos(particle.angle) * particle.speed;
      particle.x = particle.x_start;
      particle.vy = Math.sin(particle.angle) * particle.speed;
      particle.y = particle.y_start;
      //console.log(dt, particle.x_start);
      particles.push(particle)
    }
    //if (particles.length > 1000) {
    //  clearInterval(ticker)
    //}
    
    var update_sel = svg.selectAll("circle.neutron")
      .data(particles, function(d) {return d.id})
      
    update_sel.enter()
      .append("circle")
        .classed("neutron", true)
        .attr("cx", 0)
        .attr("cy", function(d) {return d.y_start})
        .attr("r", r)
        //.attr("fill", "blue")
    
    var neutrons = svg.selectAll("circle.neutron")
    neutrons  
      .attr("cx", function(d) {
        var newx = d.x_start + (elapsed - d.t0) * d.vx;
        d.old_x = d.x;
        d.x = newx;
        //if (newx > width) {d.reap = true};
        return newx;
      })
      .attr("cy", function(d) {
        var newy = d.y_start + (elapsed - d.t0) * d.vy;
        d.old_y = d.y;
        d.y = newy;
        //if (newy > height) {d.reap = true};
        return newy; 
      })

    var slits_poly = svg.selectAll("g.slit polygon")[0];
    var det_poly = svg.select("polygon.detector")[0][0];
    var sample_poly = svg.select("polygon.sample")[0][0];
    neutrons.each(function(d) {
      if (d.y > height || d.x > width) {d.reap = true; return}
      var line = [{x: d.old_x, y: d.old_y}, {x: d.x, y: d.y}];
      for (var p=0; p<slits_poly.length; p++) {
        var poly_points = slits_poly[p].points;
        var slit_intersects = linePolygonIntersects(line, poly_points, true);
        if (slit_intersects.length > 0) {
          d.reap = true;
          return
        }
      }
      var detector_intersect = linePolygonIntersects(line, det_poly.points, true);
      if (detector_intersect.length > 0) {
        d.reap = true;
        detection_handler(elapsed);
        return;
      }
      var sample_intersect = linePolygonIntersects(line, sample_poly.points, true, true);
      if (sample_intersect.length > 0) { 
        var intersect = sample_intersect[0];
        var sld = sample_def[0].sld;
        var prob = reflection_probability(intersect.rel_angle, intersect.outer, sld, k_0);
        if (Math.random() < prob) {
          d.x_start = intersect.x;
          d.y_start = intersect.y;
          d.t0 = elapsed;
          d.vx = intersect.reflection.x * d.speed;
          d.vy = intersect.reflection.y * d.speed;
        }
        return;
      }
    })
    //console.log("before: ", particles.length)
    particles = particles.filter(function(d,i) {return (d.reap != true)});
    //console.log("after: ", particles.length)
    svg.selectAll("circle.neutron")
      .data(particles, function(d) {return d.id})
      .exit().remove();
    
  }
  </script>
</body>
</html>
